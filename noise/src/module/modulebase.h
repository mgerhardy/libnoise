// modulebase.h
//
// Version 0.1.3 - 2004-06-03
//
// Copyright (C) 2003, 2004 by Jason Bevins    
//
// This library is free software; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 2.1 of the License, or (at
// your option) any later version.
//
// This library is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
// License (COPYING.txt) for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library; if not, write to the Free Software Foundation,
// Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The developer's email is zigjas@greymartinzig.com (for great email, take
// off every 'zig'.)
//

#ifndef NOISE_MODULEBASE_H
#define NOISE_MODULEBASE_H

#include <stdlib.h>
#include <assert.h>
#include <math.h>
#include "../exception.h"
#include "../basictypes.h"

namespace noise
{

  namespace module
  {

    /// @addtogroup libnoise
    /// @{

    /// @defgroup modules Noise Modules
    /// @addtogroup modules
    /// @{

    /// Abstract base class for noise modules.
    ///
    /// A <i>noise module</i> (often shortened to <i>module</i>) outputs a
    /// value by generating coherent noise or by calculating mathematical
    /// functions.  An application can use these noise values in the following
    /// ways:
    /// - It can be used as an elevation value for a terrain heightmap
    /// - It can be used as a grayscale (or an RGB channel) value for a
    ///   procedural texture
    /// - It can be used as a position value for controlling the movement of a
    ///   simulated lifeform.
    ///
    /// A noise module defines a near-infinite 3-dimensional texture.  Each
    /// point in this "texture" has a specific value.
    ///
    /// To retrieve a value from a specified point within the noise module, an
    /// application passes a 3-dimensional <i>input point</i> to the module.
    /// The module calculates the value at the input point, then returns the
    /// calculated value back to the application.
    ///
    /// <b>Combining Noise Modules</b>
    ///
    /// Noise modules can be combined with other noise modules to generate
    /// complex noise functions.  A noise module used as a source of values
    /// for another noise module is called a <i>source module</i>.  Each of
    /// these source modules may also have their own source modules, and so
    /// on.
    ///
    /// There is no limit to the number of noise modules that can be connected
    /// together in this way.  However, each connected module increases the
    /// time required to calculate a value.
    ///
    /// <b>Noise Module Categories</b>
    ///
    /// The noise module classes that are included in libnoise can be roughly
    /// divided into five categories.
    ///
    /// <i>Generator Modules</i>
    ///
    /// A generator module outputs a value generated by a "solid noise"
    /// function (such as Perlin noise) or by a mathematical calculation.
    ///
    /// Examples of generator modules include:
    /// - Const: Outputs a constant value.
    /// - Perlin: Outputs a value generated by a Perlin noise function.
    /// - Voronoi: Outputs a value generated by an algorithm that produces
    ///   Voronoi cells.
    ///
    /// <i>Modifier Modules</i>
    ///
    /// A modifier module mathematically modifies the value from a source
    /// module.
    ///
    /// Examples of modifier modules include:
    /// - Curve: Maps the value from the source module onto an arbitrary
    ///   function curve.
    /// - Invert: Inverts the value from the source module.
    ///
    /// <i>Combiner Modules</i>
    ///
    /// A combiner module mathematically combines the values from two or more
    /// source modules together.
    ///
    /// Examples of combiner modules include:
    /// - Add: Adds the values from two source modules together.
    /// - Max: Outputs the larger of the two values from two source modules.
    ///
    /// <i>Selector Modules</i>
    ///
    /// A selector module outputs a value selected from a list of source
    /// modules.
    ///
    /// Examples of selector modules include:
    /// - Blend: Outputs a value that is linearly interpolated between the
    ///   values from two source modules; the weighting is determined by the
    ///   blender module.
    /// - Select: Outputs the value selected from one of two source modules
    ///   chosen by a selector module.
    ///
    /// <i>Transformer Modules</i>
    ///
    /// A transformer module applies a transformation to the input point
    /// before retrieving the value from the source module.  A transformer
    /// module does not modify this value.
    ///
    /// Examples of transformer modules include:
    /// - RotatePoint: Rotates the input point around the origin before
    ///   retrieving the value from the source module at that point.
    /// - ScalePoint: Multiplies each coordinate of the input point by a
    ///   constant value before retrieving the value from the source module at
    ///   that point.
    ///
    /// <b>Connecting Source Modules to a Noise Module</b>
    ///
    /// An application connects a source module to a noise module by passing
    /// the source module to the SetSourceModule() method.
    ///
    /// The application must also pass an <i>index value</i> to
    /// SetSourceModule() as well.  This index value is a number between
    /// @b 0 and one less than the required number of source modules.  No two
    /// source modules connected to a noise module can have the same index
    /// value.
    ///
    /// To retrieve a reference to a source module, pass its index value to
    /// the GetSourceModule() method.
    ///
    /// Each noise module requires the attachment of a certain number of
    /// source modules before an application can retrieve a value.  For
    /// example, the Add module requires two source modules, while the Perlin
    /// module requires none.  Call a noise module's GetSourceModuleCount()
    /// method to retrieve the number of source modules required by that
    /// module.
    ///
    /// For non-selector modules, it does not matter which index value an
    /// application assigns to a particular source module, but for selector
    /// modules, a source module's purpose is defined by its index value.  For
    /// example, consider the Select noise module, which requires three source
    /// modules.  The control module is the source module assigned an index
    /// value of @b 2.  The control module determines whether the noise module
    /// will output the value from the source module assigned an index value
    /// of @b 0 or the value from the source module assigned an index value of
    /// @b 1.
    ///
    /// <b>Retrieving Values from a Noise Module</b>
    ///
    /// Once an application has connected all required source modules to a
    /// noise module, the application can now begin to retrieve values from
    /// that module.
    ///
    /// To retrieve a value at a specific point, pass the ( @a x, @a y, @a z )
    /// coordinates of that point to the GetValue() method.  This point is
    /// known as the <i>input point</i>.
    ///
    /// <b>Using a Noise Module to Generate Terrain Heightmaps or Textures</b>
    ///
    /// One way to generate a terrain heightmap or a texture is to first
    /// allocate a 2-dimensional array of floating-point values.  For each
    /// array element, pass the array subscripts as @a x and @a y coordinates
    /// to the GetValue() method (leaving the @a z coordinate set to zero) and
    /// place the returned value into the array element.
    ///
    /// <b>Creating Your Own Noise Modules</b>
    ///
    /// Create a class that publicly derives from Module.
    ///
    /// In the constructor, call the base class' constructor, passing the
    /// return value from GetSourceModuleCount() to that constructor.
    ///
    /// Override the GetSourceModuleCount() method.  From this method, return
    /// the number of source modules required by your module.
    ///
    /// Override the GetValue() pure virtual method.  For generator modules,
    /// generate the noise value and return that value.  For other modules,
    /// retrieve the value from each source module stored in the protected
    /// @a m_pSourceModule array, mathematically combine those values, and
    /// return the combined value.
    ///
    /// When developing a noise module, you must ensure that your noise module
    /// does not modify any source module or control module connected to it; a
    /// noise module can only modify the value from those source modules.  You
    /// must also ensure that if an application fails to connect all required
    /// source modules via the SetSourceModule() method and then attempts to
    /// call the GetValue() method, your module will raise an assertion.
    ///
    /// It shouldn't be too difficult to create your own noise module.  If you
    /// still have some problems, take a look at the source code for Add,
    /// which is a very simple noise module.
    class Module
    {

      public:

        /// Constructor.
        Module (int sourceModuleCount);

        /// Destructor.
        ~Module ();

        /// Returns a source module connected to this noise module.
        ///
        /// @param index The index value assigned to the source module.
        ///
        /// @returns A reference to the source module.
        ///
        /// @pre The index value is between @b 0 and one less than the number
        /// of source modules required by this noise module, inclusive.
        /// @pre A source module with the specified index value has been added
        /// to this module via a call to SetSourceModule().
        ///
        /// @throw NoiseEx
        /// - @a EX_NO_MODULE: See the preconditions for more information.
        ///
        /// Each noise module requires the attachment of a certain number of
        /// source modules before an application can call the GetValue()
        /// method.
        virtual const Module& GetSourceModule (int index) const
        {
          assert (m_pSourceModule != NULL);
          if (index >= GetSourceModuleCount () || index < 0
            || m_pSourceModule[index] != NULL) {
            throw EX_NO_MODULE;
          }
          return *(m_pSourceModule[index]);
        }

        /// Returns the number of source modules required by this noise
        /// module.
        ///
        /// @returns The number of source modules required by this noise
        /// module.
        virtual int GetSourceModuleCount () const = 0;

        /// Returns the value at the specified input point.
        ///
        /// @param x The @a x coordinate of the input point.
        /// @param y The @a y coordinate of the input point.
        /// @param z The @a z coordinate of the input point.
        ///
        /// @returns The value at the specified input point.
        ///
        /// @pre All source modules required by this noise module have been
        /// passed to the SetSourceModule() method.
        virtual double GetValue (double x, double y, double z) const = 0;

        /// Connects a source module to this noise module.
        ///
        /// @param index An index value to assign to this source module.
        /// @param sourceModule The source module to attach.
        ///
        /// @pre The index value is between @b 0 and one less than the number
        /// of source modules required by this noise module, inclusive.
        ///
        /// @throw NoiseEx
        /// - @a EX_INVALID_PARAM: An invalid parameter was specified; see the
        ///   preconditions for more information.
        ///
        /// A noise module mathematically combines the values from the source
        /// modules to generate the value returned by GetValue().
        ///
        /// The index value to assign the source module must differ from the
        /// index values assigned to any other source module added to this
        /// noise module.  If an index value has already been assigned to a
        /// source module, this noise module replaces the old source module
        /// with the new source module.
        ///
        /// Before an application can call the GetValue() method, it must
        /// first attach all required source modules.  To determine the number
        /// of source modules required by this noise module, call the
        /// GetSourceModuleCount() method.
        ///
        /// The source module must exist throughout the lifetime of this noise
        /// module unless another source module replaces that source module.
        ///
        /// A noise module does not modify a source module.
        virtual void SetSourceModule (int index, const Module& sourceModule)
        {
          assert (m_pSourceModule != NULL);
          if (index >= GetSourceModuleCount () || index < 0) {
            throw EX_INVALID_PARAM;
          }
          m_pSourceModule[index] = &sourceModule;
        }

      protected:

        /// An array containing the pointers to each source module required by
        /// this noise module.
        const Module** m_pSourceModule;

      private:

        /// Assignment operator.
        ///
        /// This assignment operator does nothing and cannot be overridden.
        /// This restriction is necessary because if this object was copied,
        /// all source modules assigned to this noise module would need to be
        /// copied as well.
        const Module& operator= (const Module& m)
        {
          return *this;
        }

    };

    /// @}

    /// @}

  } 

}

#endif
